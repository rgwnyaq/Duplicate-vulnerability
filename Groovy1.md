## 背景介绍
### Groovy
Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，他结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好的结合，也能用于扩展现有的代码。    
### 漏洞定位（CVE-2015-3253）
org.codehaus.groovy.runtime.MethodClosure 类中存在代码可以动态调用指定对象的指定方法。
```
    protected Object doCall(Object arguments) {
        return InvokerHelper.invokeMethod(this.getOwner(), this.method, arguments);
    }
```
那么就写一个测试代码，来调用MethodClosure类，触发漏洞： 
```
import org.codehaus.groovy.runtime.MethodClosure;
public class test {
    public static void main(final String[] args) throws Exception{
        MethodClosure mc=null;
        try{
            mc=new MethodClosure((new ProcessBuilder("cmd.exe","/c","calc.exe")),"start");
        }catch(Exception e){e.printStackTrace();}
        mc.call();
    }
}
```
### 分析
#### 漏洞产生原因
![avatar](/pictures/methodclosure.png)   
进入MethodClosure就看到了注释“Represents a method on an object using a closure which can be invoked”，表示了可调用闭包的对象上的方法。   
看到59行的doCall()这里动态调用触发我们构造的ProcessBuilder中的内容，造成了命令执行。    
![avatar](/pictures/call().png)        
上述显示了[官方](http://docs.groovy-lang.org/2.4.7/html/gapi/groovy/lang/Closure.html)对call()的解释，call()调用闭包。下面显示了closure中call的具体使用，我们可以看到这里call没有参数时，会为其加入NOARGS，然后进入到含有参数的call的调用中，423行显示了为什么这个漏洞会触发doCall()，实现动态调用实现命令执行。  
![avatar](/pictures/closure.png)   

#### 漏洞流程
首先展示一下整个漏洞流程：  
![avatar](/pictures/liucheng.png)   
由测试代码中的mc.call()，进入到closure.java中的call，进入了423行，就看到了invokemethod，跟进去来到MetaClasslmpl.java的invokeMethod()。此时的MethodName为doCall，      
![avatar](/pictures/ownerinvoke.png)   
看到1074行，此时这里就调用了doCall方法，并再次回到MetaClasslmpl.java的invokeMethod()，而此时的MethodName已变为了start。后面的就是调到最里面的ProcessBuiler执行命令了。


## 利用链
上述的漏洞触发点，在真正的代码中很难直接遇到。更多的是需要去寻找其他方法调用了这里的call()的。idea中快捷键Ctrl+Alt+H，可以看到很多方法都调用了call。例如HashCode等，现在要做的就是怎样构造或者说怎么去寻找到可利用的这些方法，再进一步的调用call来触发漏洞。    
首先要说的就是在调试过程中，经常还未到定位点的时候就遇到了弹计算器的情况。是因为idea在识别代理时，识别到里面含有Map接口，所以会去调用entrySet获取内容进行展示。    
在关闭idea的debug选项中的“Enable alternative view for Collections classes”则在调试过程中不再执行命令。
### entrySet
由于Map中存放的元素均为键值对，故每一个键值对必然存在一个映射关系。Map中采用Entry内部类来表示一个映射项，映射项包含Key和Value。        
Set<Entry<T,V>> entrySet()该方法返回值就是这个map中各个键值对映射关系的集合。可使用它对map进行遍历。     
通过对这些特性，可以巧妙构造出很多方式来触发漏洞。

### Gadget chain（ysoserial注释）：
	Gadget chain:
		ObjectInputStream.readObject()
			PriorityQueue.readObject()
				Comparator.compare() (Proxy)
					ConvertedClosure.invoke()
						MethodClosure.call()
							...
						  		Method.invoke()
									Runtime.exec()


## 参考文献
https://www.cnblogs.com/magic-zero/p/9755413.html       
https://www.anquanke.com/post/id/202730     
https://blog.csdn.net/fnmsd/article/details/88959428        
https://xz.aliyun.com/t/2041#toc-5
